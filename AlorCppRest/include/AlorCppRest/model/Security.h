/**
 * Alor OpenAPI V2
 * API для работы с торговой системой АЛОР Брокер. Предоставляет интерфейсы для выставления заявок и получения биржевой информации.  Данные для неавторизованных запросов предоставляются с задержкой от 15 минут, для авторизованных - без задержек.   Публичная биржевая информация может быть получена через HTTP(S) API, а также доступна через однократно установленное WebSocket соединение. <br> **Внимание!** WebSocket соединения могут и будут разрываться *(например, если клиент не успевает обрабатывать сообщения и на стороне API в буфере накопится более 5000 событий)*. <br> Во внешнем ПО необходимо предусмотреть механизмы переподключения и переподписки (при необходимости)! <br> <br>  В OpenAPI V2 доступны \"Московская Биржа\" (MOEX) и \"Биржа СПБ\" (SPBX).   <h4> Доступные типы данных </h4>  * Все сделки  * Все заявки  * Информация по инструментам  * Котировки  * Биржевые стаканы  * Исторические данные  * Позиции  * Информация о клиенте  <h4>Поддерживаемые виды заявок</h4>  * рыночные  * лимитные  * стоп-лосс  * тейк-профит  * стоп-лосс лимит  * тейк-профит лимит  <h4>    Ограничения по частоте запросов     </h4> <p>На текущий момент ограничений по количеству запросов в минуту нет, однако есть ограничение на общее количество подписок (сотни тысяч). При достижении лимита подписок клиент будет заблокирован и в течение нескольких минут не сможет создавать новые подписки. Уже существующие подписки продолжат работать. <br/>  Сервер может обрабатывать \"тяжелые\" запросы (пример - история за все время) и запросы без авторизации с меньшим приоритетом.<br/> </p>  <h4>Получение списка портфелей</h4> <p>Получить список доступных портфелей можно из JWT токена</p> <p>Для получения списка доступных портфелей необходимо декодировать JWT токен. Портфели находятся в поле <b>portfolios</b>.</p> <br/>  <h2> Авторизация </h2>  <h4>OAuth</h4>  <b>Внимание!</b>   JWT и refresh token — равносильны логину и паролю. Их нужно скрывать от публичного доступа.  <h4>Для разработчиков сторонних приложений, в которых торговлю будут вести их пользователи.</h4>  Мы предоставляем сервис для авторизации сторониих приложений по стандарту OAuth 2.0. С примером приложения, использующего OAuth сервис для авторизации пользователей можно ознакомиться в разделе  <a href=\"/examples\">Примеры</a>.  Список разрешений (scopes), которые могут быть выданы приложению: <table>   <tr>     <td><b>OrdersRead</b></td>     <td>Чтение выставленных заявок</td>   </tr>   <tr>     <td><b>OrdersCreate</b></td>     <td>Выставление заявок</td>   </tr>   <tr>     <td><b>Trades</b></td>     <td>Чтение совершенных сделок</td>   </tr>   <tr>     <td><b>Personal</b></td>     <td>Персональная информация: ФИО, почта и т.п.</td>   </tr>   <tr>     <td><b>Stats</b></td>     <td>Статистика: прибыль, средние цены и т.п.</td>   </tr> </table>  <h4>Для ведения операций от своего имени</h4>  Выписать себе <b>refresh token</b> для ведения операций от своего имени [можно здесь](https://alor.dev/open-api-tokens).  <h2>Краткое описание работы с авторизацией</h2>  Чтобы выполнить авторизованный запрос, добавьте в запрос заголовок с именем \"Authorization\" и значением, состоящим из префикса `\"Bearer \"` и валидного JWT токена.  Срок жизни JWT короткий: это сделано для безопасности.  Для большинства вариантов использования API мы рекоммендуем использовать механизм  <b>refresh token</b> .  Механизм  <b>refresh token</b>  позволяет получать JWT с новым сроком жизни. Для этого отправьте POST запрос на адрес `https://oauthdev.alor.ru/refresh?token={refreshToken}` *(тестовый контур)* или `https://oauth.alor.ru/refresh?token={refreshToken}` *(боевой контур)*. Если у  <b>refresh token</b>  не истек срок жизни и не он не был отозван, то в теле ответа в поле AccessToken вернётся свежий JWT токен.   Срок жизни  <b>refresh token</b>, получаемого обычным способом — 1 месяц.   Срок жизни  <b>refresh token</b>, получаемого самостоятельным выписыванием — год.  | |-  > Если мы для вас не завели портфели для ведения торговли в игровом контуре, оставьте заявку на <a href=\"mailto:openapi@alor.ru\">openapi@alor.ru</a> или свяжитесь с нами в [телеграме](https://t.me/AlorOpenAPI).  </br></br> Тестовый контур: `https://apidev.alor.ru`  Боевой контур: `https://api.alor.ru` 
 *
 * The version of the OpenAPI document: 1.0
 * Contact: openapi@alor.ru
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 6.6.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

/*
 * Security.h
 *
 * 
 */

#ifndef ALORMODEL_Security_H_
#define ALORMODEL_Security_H_


#include "AlorCppRest/ModelBase.h"

#include "AlorCppRest/model/ComplexProductCategory.h"
#include <cpprest/details/basic_types.h>

namespace alormodel {


/// <summary>
/// 
/// </summary>
class  Security
    : public ModelBase
{
public:
    Security();
    virtual ~Security();

    /////////////////////////////////////////////
    /// ModelBase overrides

    void validate() override;

    web::json::value toJson() const override;
    bool fromJson(const web::json::value& json) override;

    void toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) const override;
    bool fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& namePrefix) override;

    /////////////////////////////////////////////
    /// Security members

    /// <summary>
    /// Тикер (Код финансового инструмента)
    /// </summary>
    utility::string_t getSymbol() const;
    bool symbolIsSet() const;
    void unsetSymbol();

    void setSymbol(const utility::string_t& value);

    /// <summary>
    /// Краткое наименование инструмента
    /// </summary>
    utility::string_t getShortname() const;
    bool shortnameIsSet() const;
    void unsetShortname();

    void setShortname(const utility::string_t& value);

    /// <summary>
    /// Краткое описание инструмента
    /// </summary>
    utility::string_t getDescription() const;
    bool descriptionIsSet() const;
    void unsetDescription();

    void setDescription(const utility::string_t& value);

    /// <summary>
    /// Биржа
    /// </summary>
    utility::string_t getExchange() const;
    bool exchangeIsSet() const;
    void unsetExchange();

    void setExchange(const utility::string_t& value);

    /// <summary>
    /// Тип
    /// </summary>
    utility::string_t getType() const;
    bool typeIsSet() const;
    void unsetType();

    void setType(const utility::string_t& value);

    /// <summary>
    /// Размер лота
    /// </summary>
    double getLotsize() const;
    bool lotsizeIsSet() const;
    void unsetLotsize();

    void setLotsize(double value);

    /// <summary>
    /// Номинальная стоимость
    /// </summary>
    double getFacevalue() const;
    bool facevalueIsSet() const;
    void unsetFacevalue();

    void setFacevalue(double value);

    /// <summary>
    /// Тип ценной бумаги согласно стандарту ISO 10962
    /// </summary>
    utility::string_t getCfiCode() const;
    bool cfiCodeIsSet() const;
    void unsetCfiCode();

    void setCfiCode(const utility::string_t& value);

    /// <summary>
    /// Дата и время (UTC) окончания действия
    /// </summary>
    utility::string_t getCancellation() const;
    bool cancellationIsSet() const;
    void unsetCancellation();

    void setCancellation(const utility::string_t& value);

    /// <summary>
    /// Минимальный шаг цены
    /// </summary>
    double getMinstep() const;
    bool minstepIsSet() const;
    void unsetMinstep();

    void setMinstep(double value);

    /// <summary>
    /// 
    /// </summary>
    double getRating() const;
    bool ratingIsSet() const;
    void unsetRating();

    void setRating(double value);

    /// <summary>
    /// Цена маржинальной покупки (заемные средства)
    /// </summary>
    double getMarginbuy() const;
    bool marginbuyIsSet() const;
    void unsetMarginbuy();

    void setMarginbuy(double value);

    /// <summary>
    /// Цена маржинальной продажи (заемные средства)
    /// </summary>
    double getMarginsell() const;
    bool marginsellIsSet() const;
    void unsetMarginsell();

    void setMarginsell(double value);

    /// <summary>
    /// Отношение цены маржинальной покупки к цене последней сделки
    /// </summary>
    double getMarginrate() const;
    bool marginrateIsSet() const;
    void unsetMarginrate();

    void setMarginrate(double value);

    /// <summary>
    /// Минимальный шаг цены, выраженный в рублях
    /// </summary>
    double getPricestep() const;
    bool pricestepIsSet() const;
    void unsetPricestep();

    void setPricestep(double value);

    /// <summary>
    /// Максимальная цена
    /// </summary>
    double getPriceMax() const;
    bool priceMaxIsSet() const;
    void unsetPriceMax();

    void setPriceMax(double value);

    /// <summary>
    /// Минимальная цена
    /// </summary>
    double getPriceMin() const;
    bool priceMinIsSet() const;
    void unsetPriceMin();

    void setPriceMin(double value);

    /// <summary>
    /// Теоретическая цена опциона
    /// </summary>
    double getTheorPrice() const;
    bool theorPriceIsSet() const;
    void unsetTheorPrice();

    void setTheorPrice(double value);

    /// <summary>
    /// Теоретическая цена опциона с учетом лимитов
    /// </summary>
    double getTheorPriceLimit() const;
    bool theorPriceLimitIsSet() const;
    void unsetTheorPriceLimit();

    void setTheorPriceLimit(double value);

    /// <summary>
    /// Волатильность
    /// </summary>
    double getVolatility() const;
    bool volatilityIsSet() const;
    void unsetVolatility();

    void setVolatility(double value);

    /// <summary>
    /// Валюта
    /// </summary>
    utility::string_t getCurrency() const;
    bool currencyIsSet() const;
    void unsetCurrency();

    void setCurrency(const utility::string_t& value);

    /// <summary>
    /// Идентификатор ценной бумаги согласно стандарту ISO 6166
    /// </summary>
    utility::string_t getISIN() const;
    bool iSINIsSet() const;
    void unsetISIN();

    void setISIN(const utility::string_t& value);

    /// <summary>
    /// 
    /// </summary>
    int32_t getYield() const;
    bool yieldIsSet() const;
    void unsetYield();

    void setYield(int32_t value);

    /// <summary>
    /// Код режима торгов
    /// </summary>
    utility::string_t getPrimaryBoard() const;
    bool primaryBoardIsSet() const;
    void unsetPrimary_board();

    void setPrimaryBoard(const utility::string_t& value);

    /// <summary>
    /// Торговый статус инструмента:   * &#x60;18&#x60; - Нет торгов / торги закрыты   * &#x60;118&#x60; - Период открытия   * &#x60;103&#x60; - Период закрытия   * &#x60;2&#x60; - Перерыв в торгах   * &#x60;17&#x60; - Нормальный период торгов   * &#x60;102&#x60; - Аукцион закрытия   * &#x60;106&#x60; - Аукцион крупных пакетов   * &#x60;107&#x60; - Дискретный аукцион   * &#x60;119&#x60; - Аукцион открытия   * &#x60;120&#x60; - Период торгов по цене аукциона закрытия 
    /// </summary>
    int32_t getTradingStatus() const;
    bool tradingStatusIsSet() const;
    void unsetTradingStatus();

    void setTradingStatus(int32_t value);

    /// <summary>
    /// Описание торгового статуса инструмента
    /// </summary>
    utility::string_t getTradingStatusInfo() const;
    bool tradingStatusInfoIsSet() const;
    void unsetTradingStatusInfo();

    void setTradingStatusInfo(const utility::string_t& value);

    /// <summary>
    /// 
    /// </summary>
    std::shared_ptr<ComplexProductCategory> getComplexProductCategory() const;
    bool complexProductCategoryIsSet() const;
    void unsetComplexProductCategory();

    void setComplexProductCategory(const std::shared_ptr<ComplexProductCategory>& value);


protected:
    utility::string_t m_Symbol;
    bool m_SymbolIsSet;
    utility::string_t m_Shortname;
    bool m_ShortnameIsSet;
    utility::string_t m_Description;
    bool m_DescriptionIsSet;
    utility::string_t m_Exchange;
    bool m_ExchangeIsSet;
    utility::string_t m_Type;
    bool m_TypeIsSet;
    double m_Lotsize;
    bool m_LotsizeIsSet;
    double m_Facevalue;
    bool m_FacevalueIsSet;
    utility::string_t m_CfiCode;
    bool m_CfiCodeIsSet;
    utility::string_t m_Cancellation;
    bool m_CancellationIsSet;
    double m_Minstep;
    bool m_MinstepIsSet;
    double m_Rating;
    bool m_RatingIsSet;
    double m_Marginbuy;
    bool m_MarginbuyIsSet;
    double m_Marginsell;
    bool m_MarginsellIsSet;
    double m_Marginrate;
    bool m_MarginrateIsSet;
    double m_Pricestep;
    bool m_PricestepIsSet;
    double m_PriceMax;
    bool m_PriceMaxIsSet;
    double m_PriceMin;
    bool m_PriceMinIsSet;
    double m_TheorPrice;
    bool m_TheorPriceIsSet;
    double m_TheorPriceLimit;
    bool m_TheorPriceLimitIsSet;
    double m_Volatility;
    bool m_VolatilityIsSet;
    utility::string_t m_Currency;
    bool m_CurrencyIsSet;
    utility::string_t m_ISIN;
    bool m_ISINIsSet;
    int32_t m_Yield;
    bool m_YieldIsSet;
    utility::string_t m_Primary_board;
    bool m_Primary_boardIsSet;
    int32_t m_TradingStatus;
    bool m_TradingStatusIsSet;
    utility::string_t m_TradingStatusInfo;
    bool m_TradingStatusInfoIsSet;
    std::shared_ptr<ComplexProductCategory> m_ComplexProductCategory;
    bool m_ComplexProductCategoryIsSet;
};


}

#endif /* ALORMODEL_Security_H_ */
